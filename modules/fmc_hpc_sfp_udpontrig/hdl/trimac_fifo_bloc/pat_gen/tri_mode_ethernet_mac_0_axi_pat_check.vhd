--------------------------------------------------------------------------------
-- File       : tri_mode_ethernet_mac_0_axi_pat_check.v
-- Author     : Xilinx Inc.
-- -----------------------------------------------------------------------------
-- (c) Copyright 2010 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
-- -----------------------------------------------------------------------------
-- Description:  A simple pattern checker - expects the same data pattern as generated by the pat_gen
-- with the same DA/SA order (it is expected that the frames will pass through
-- two address swap blocks).  the checker will first sync to the data and then
-- identify any errors (this is a sticky output but the internal signal is
-- per byte)
--
--------------------------------------------------------------------------------

library unisim;
use unisim.vcomponents.all;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;


entity tri_mode_ethernet_mac_0_axi_pat_check is
   generic (
      DEST_ADDR            : bit_vector(47 downto 0) := X"da0102030405";
      SRC_ADDR             : bit_vector(47 downto 0) := X"5a0102030405";
      MAX_SIZE             : unsigned(11 downto 0) := X"1f4";
      MIN_SIZE             : unsigned(11 downto 0) := X"040";
      ENABLE_VLAN          : boolean := false;
      VLAN_ID              : bit_vector(11 downto 0) := X"002";
      VLAN_PRIORITY        : bit_vector(2 downto 0) := "010"
   );
   port (
      axi_tclk             : in  std_logic;
      axi_tresetn          : in  std_logic;

      enable_pat_chk       : in  std_logic;
      speed                : in  std_logic_vector(1 downto 0);

      tdata                : in  std_logic_vector(7 downto 0);
      tvalid               : in  std_logic;
      tlast                : in  std_logic;
      tready               : in  std_logic;
      tuser                : in  std_logic;

      frame_error          : out std_logic;
      activity_flash       : out std_logic
   );
end tri_mode_ethernet_mac_0_axi_pat_check;

architecture rtl of tri_mode_ethernet_mac_0_axi_pat_check is

   -- State machine
   type state_typ is    (IDLE,
                         INFO,
                         LOOK,
                         PKT);

   function Sel (Cond : boolean; A,B : integer) return integer is
     begin
         if Cond then
            return A;
         else
            return B;
         end if;
   end function Sel;


   -- work out the adjustment required to get the right packet size.
   constant PKT_ADJUST        : integer := Sel(ENABLE_VLAN,22,18);

   -- generate the vlan fields
   constant VLAN_HEADER       : bit_vector(31 downto 0) := X"8100" & VLAN_PRIORITY & '0' & VLAN_ID;

   -- generate the require header count compare
   constant HEADER_LENGTH     : integer := Sel(ENABLE_VLAN,15,11);

   signal errored_data        : std_logic;
   signal errored_addr_data   : std_logic;
   signal errored_swap_data   : std_logic;
   signal lut_data            : std_logic_vector(7 downto 0);
   signal lut_swap_data       : std_logic_vector(7 downto 0);
   signal expected_data       : unsigned(7 downto 0) := (others => '0');
   signal packet_size         : unsigned(15 downto 0) := (others => '0');
   signal packet_count        : unsigned(4 downto 0) := (others => '0');
   signal next_rx_state       : state_typ;
   signal rx_state            : state_typ;
   signal maybe_frame_error   : std_logic;
   signal frame_error_int     : std_logic;
   signal frame_activity_count: unsigned(15 downto 0) := (others => '0');
   signal sm_active           : std_logic;
   constant dummy             : bit_vector(47 downto 0) := (others => '0');



begin

-- link flasher to a bit of the counter depending upon the speed to give a good flash rate
activity_flash <= frame_activity_count(15) when speed(1) = '1' else
                  frame_activity_count(13) when speed(0) = '1' else frame_activity_count(11);

frame_error    <= frame_error_int when sm_active = '1' else '0';

-- we need a way to confirm data has been received to ensure that if no data is received it is
-- flagged as an error
active_p : process (axi_tclk)
begin
   if axi_tclk'event and axi_tclk = '1' then
      if axi_tresetn = '0' then
         sm_active <= '0';
      elsif rx_state = PKT then
         sm_active <= '1';
      end if;
   end if;
end process active_p;

-- the pattern checker is a slave in all respects so has to look for ackowledged data
-- the first and 6 bytes of data are compared against the first byte of DEST_ADDR and SCR_ADDR
-- to allow for address swaps being removed

-- a simple state machine will keep track of the packet position
next_s : process(rx_state, tlast, tvalid, tready, tuser, enable_pat_chk, maybe_frame_error)
begin
   next_rx_state <= rx_state;
   case rx_state is
      -- cannot simply look for a rise on valid have to see a last first so
      -- we know the next asserted valid is new data
      when IDLE =>
         if tlast = '1' and tvalid = '1' and tready = '1' and enable_pat_chk = '1' then
            next_rx_state <= INFO;
         end if;
      -- since we don't know where the packet gen will be rx a frame to enable
      -- packet size to be initialised
      when INFO =>
         if tlast = '1' and tvalid = '1' and tready = '1'  and tuser = '0' then
            next_rx_state <= LOOK;
         end if;
      -- have seen a last so now look for a start
      when LOOK =>
         if tlast = '0' and tvalid = '1' and tready = '1' then
            next_rx_state <= PKT;
         end if;
      -- rxd first byte of packet - now stay in this state until we see a last
      when PKT =>
         if enable_pat_chk = '0' then
            next_rx_state <= IDLE;
         elsif tlast = '1' and tvalid = '1' and tready = '1' then
            if tuser = '0' and maybe_frame_error = '1' then
               next_rx_state <= IDLE;
            else
               next_rx_state <= LOOK;
            end if;
         end if;
   end case;
end process;

state_p : process (axi_tclk)
begin
   if axi_tclk'event and axi_tclk = '1' then
      if axi_tresetn = '0' then
         rx_state <= IDLE;
      else
         rx_state <= next_rx_state;
      end if;
   end if;
end process state_p;

result_p : process (axi_tclk)
begin
   if axi_tclk'event and axi_tclk = '1' then
      if rx_state = PKT and next_rx_state = LOOK then
         if tuser = '0' then
            if ENABLE_VLAN then
               if errored_addr_data = '1' then
                  assert false
                    report "VLAN Frame PASSED.  DA/SA swapped" & cr
                    severity note;
               else
                  assert false
                    report "VLAN Frame PASSED." & cr
                    severity note;
               end if;
            else
               if errored_addr_data = '1' then
                  assert false
                    report "Frame PASSED.  DA/SA swapped" & cr
                    severity note;
               else
                  assert false
                    report "Frame PASSED." & cr
                    severity note;
               end if;
            end if;
         end if;
      end if;
   end if;
end process result_p;

-- now need a counter for packet size and packet position AND data
pkt_count_p : process (axi_tclk)
begin
   if axi_tclk'event and axi_tclk = '1' then
      if axi_tresetn = '0' then
         packet_count <= (others => '0');
      else
         if tlast = '1' then
            packet_count <= (others => '0');
         elsif (next_rx_state = PKT or rx_state = PKT or rx_state = INFO) and tvalid = '1' and
             tready = '1' and packet_count(4 downto 3) /= "11" then
            packet_count <= packet_count + "00001";
         end if;
      end if;
   end if;
end process pkt_count_p;

-- need to get packet size info
-- this is first initialised during the info state (the assumption being that
-- the generate sends incrementing packet sizes (wrapping at MAX_SIZE)
pkt_size_p : process (axi_tclk)
begin
   if axi_tclk'event and axi_tclk = '1' then
      if rx_state = INFO and packet_count = (HEADER_LENGTH+1) and tvalid = '1' and tready = '1' then
         packet_size(15 downto 8) <= unsigned(tdata);
      elsif rx_state = INFO and packet_count = (HEADER_LENGTH+2) and tvalid = '1' and tready = '1' then
         packet_size(7 downto 0) <= unsigned(tdata);
      -- when in the LOOK state we want to update the packet size to the next expected
      elsif rx_state /= LOOK and next_rx_state = LOOK and tuser = '0' then
         if packet_size(11 downto 0) = MAX_SIZE - PKT_ADJUST then
            packet_size <= X"0" & (MIN_SIZE - PKT_ADJUST);
         else
            packet_size <= packet_size + X"0001";
         end if;
      end if;
   end if;
end process pkt_size_p;

exp_data_p : process (axi_tclk)
begin
   if axi_tclk'event and axi_tclk = '1' then
      if rx_state = LOOK and next_rx_state = PKT then
         expected_data <= packet_size(7 downto 0);
      elsif rx_state = PKT and packet_count >= (HEADER_LENGTH+3) and tvalid = '1' and tready = '1' then
         expected_data <= expected_data - X"01";
      end if;
   end if;
end process exp_data_p;

-- store the parametised values in a lut (64 deep)
-- this should mean the values could be adjusted in fpga_editor etc..
LUT6_gen : for I in 0 to 7 generate
begin
   LUT6_inst : LUT6
   generic map (
      INIT           => dummy &
                           VLAN_HEADER(i) &
                           VLAN_HEADER(i+8) &
                           VLAN_HEADER(i+16) &
                           VLAN_HEADER(i+24) &
                           SRC_ADDR(I) &
                           SRC_ADDR(I+8) &
                           SRC_ADDR(I+16) &
                           SRC_ADDR(I+24) &
                           SRC_ADDR(I+32) &
                           SRC_ADDR(I+40) &
                           DEST_ADDR(I) &
                           DEST_ADDR(I+8) &
                           DEST_ADDR(I+16) &
                           DEST_ADDR(I+24) &
                           DEST_ADDR(I+32) &
                           DEST_ADDR(I+40)
   )
   port map (
     O    => lut_data(I),
     I0   => packet_count(0),
     I1   => packet_count(1),
     I2   => packet_count(2),
     I3   => packet_count(3),
     I4   => '0',
     I5   => '0'
   );

   LUT6_swap_inst : LUT6
   generic map (
      INIT           => dummy &
                           VLAN_HEADER(i) &
                           VLAN_HEADER(i+8) &
                           VLAN_HEADER(i+16) &
                           VLAN_HEADER(i+24) &
                           DEST_ADDR(I) &
                           DEST_ADDR(I+8) &
                           DEST_ADDR(I+16) &
                           DEST_ADDR(I+24) &
                           DEST_ADDR(I+32) &
                           DEST_ADDR(I+40) &
                           SRC_ADDR(I) &
                           SRC_ADDR(I+8) &
                           SRC_ADDR(I+16) &
                           SRC_ADDR(I+24) &
                           SRC_ADDR(I+32) &
                           SRC_ADDR(I+40)
   )
   port map (
     O    => lut_swap_data(I),
     I0   => packet_count(0),
     I1   => packet_count(1),
     I2   => packet_count(2),
     I3   => packet_count(3),
     I4   => '0',
     I5   => '0'
   );
end generate;

-- we do not know if the address will be swapped or not so check for both - if either pass
-- then this field is ok (assumption being that an address swap cannot be performed by mistake.)
-- errored_data is high on the cycle after a mismatch and stays high until the end of frame
error_addr_p : process (axi_tclk)
begin
   if axi_tclk'event and axi_tclk = '1' then
      if axi_tresetn = '0' then
         errored_addr_data <= '0';
      elsif tlast = '1' and tvalid = '1' and tready = '1' then
         errored_addr_data <= '0';
      elsif packet_count <= HEADER_LENGTH and tvalid = '1' and tready = '1' and tuser = '0' then
         if lut_data /= tdata then
            errored_addr_data <= '1';
         end if;
      end if;
   end if;
end process error_addr_p;

-- errored_data is high on the cycle after a mismatch and stays high until the end of frame
error_addr_swap_p : process (axi_tclk)
begin
   if axi_tclk'event and axi_tclk = '1' then
      if axi_tresetn = '0' then
         errored_swap_data <= '0';
      elsif tlast = '1' and tvalid = '1' and tready = '1' then
         errored_swap_data <= '0';
      elsif packet_count <= HEADER_LENGTH and tvalid = '1' and tready = '1' and tuser = '0' then
         if lut_swap_data /= tdata then
            errored_swap_data <= '1';
         end if;
      end if;
   end if;
end process error_addr_swap_p;

-- finally the check states - errored_data is only high on the cycle after a mismatch
chk_data_p : process (axi_tclk)
begin
   if axi_tclk'event and axi_tclk = '1' then
      errored_data <= '0';
      if packet_count = (HEADER_LENGTH+1) and tvalid = '1' and tready = '1' and tuser = '0' then
         if packet_size(15 downto 8) /= unsigned(tdata) then
            errored_data <= '1';
         end if;
      elsif packet_count = (HEADER_LENGTH+2) and tvalid = '1' and tready = '1' and tuser = '0' then
         if packet_size(7 downto 0) /= unsigned(tdata) then
            errored_data <= '1';
         end if;
      elsif packet_count >= (HEADER_LENGTH+3) and tvalid = '1' and tready = '1' and tuser = '0' and rx_state = PKT then
         if expected_data /= unsigned(tdata) then
            errored_data <= '1';
         end if;
      end if;
   end if;
end process chk_data_p;

maybe_error_p : process (axi_tclk)
begin
   if axi_tclk'event and axi_tclk = '1' then
      if axi_tresetn = '0' then
         maybe_frame_error <= '0';
      elsif (tlast = '1' and tvalid = '1' and tready = '1' and tuser = '1') or rx_state = IDLE then
         maybe_frame_error <= '0';
      elsif rx_state /= IDLE and rx_state /= INFO and (errored_data = '1' or (errored_addr_data = '1' and errored_swap_data = '1')) then
         maybe_frame_error <= '1';
      end if;
   end if;
end process maybe_error_p;

-- capture the error and hold until reset
error_p : process (axi_tclk)
begin
   if axi_tclk'event and axi_tclk = '1' then
      if axi_tresetn = '0' then
         frame_error_int <= '0';
      elsif maybe_frame_error = '1' and tlast = '1' and tready = '1' and tvalid = '1' and tuser = '0' then
         frame_error_int <= '1';
      end if;
   end if;
end process error_p;

-- need a counter for frame activity to provide some feedback that frames are being received
-- a 16 bit counter is used as this should give a slow flash rate at 10M and a very fast rate at 1G
flash_p : process (axi_tclk)
begin
   if axi_tclk'event and axi_tclk = '1' then
      if axi_tresetn = '0' then
         frame_activity_count <= (others => '0');
      elsif tlast = '1' then
         frame_activity_count <= frame_activity_count + X"0001";
      end if;
   end if;
end process flash_p;

end rtl;
