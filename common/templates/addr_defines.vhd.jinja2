-- AUTOGENERATED
{#  Template for the address defines file, this will automatically generate the
        chip selects and the NUM constants for the different blocks. Taken from and
        addr_defines_template and updated to current naming scheme                #}
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package addr_defines is

-- Functional Address Space Chip Selects
{# REG and DRV are hard coded as they do not act as blocks in the same way but
still need to be given Chip Select values. #}
    constant REG_CS : natural := 0;
    constant DRV_CS : natural := 1;
{% for block in fpga_blocks %}
    constant {{ block.name|upper }}_CS : natural := {{ block.block_address }};
    {% if loop.last %}

-- Constant for the number of used modules
    constant USED_MOD_COUNT : natural := {{ loop.index + 1 }};
    {% endif %}
{# This is +1 to account for chipselects 0 and 1 assigned to reg and drv #}
{% endfor %}

-- Block instantiation
{% for block in fpga_blocks %}
    constant {{ block.name|upper }}_NUM : natural := {{ block.number }};
{% endfor %}

-- Constant equal to the sum of block nums for each bit out signal
    constant BIT_BUS_SIZE : natural := {{ carrier_bit_bus_length }};

-- Constant equal to the sum of block_num for each pos out signal
    constant POS_BUS_SIZE : natural := {{ carrier_pos_bus_length }};

-- Constant equal to the number of carrier modules
    constant CARRIER_MOD_COUNT : natural := {{ carrier_mod_count }};

-- Constant equal to the number of long tables
    constant DMA_USERS_COUNT : natural := {{ dma_users_count }};

-- Block Register Address Space


{% for block in register_blocks %}
-- {{ block.entity }} Block:
        {% for field in block.fields %}
                {% for register in field.numbered_registers() %}
    constant {{ block.entity|upper }}_{{ register.name }}_addr : natural := {{ register.number }};
                {% endfor %}
        {% endfor %}

{% endfor %}
end addr_defines;

package body addr_defines is


end addr_defines;
