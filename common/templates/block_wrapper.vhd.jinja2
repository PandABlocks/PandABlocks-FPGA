-- AUTOGENERATED
--------------------------------------------------------------------------------
-- Top-level VHDL wrapper for a block
-- This is responsible for creating {{ number }} instances of a {{ name }} Block
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library work;
use work.top_defines.all;


entity {{ entity }}_wrapper is
generic (
    NUM : natural := 1
);
port (
    -- Clocks and Resets
    clk_i               : in  std_logic;
    reset_i             : in  std_logic;

    -- Bus inputs
    bit_bus_i           : in  bit_bus_t;
    pos_bus_i           : in  pos_bus_t;

    -- Bus outputs
{% for field in filter_fields("bit_out") %}
    {{ pad(field.name + "_o") }} : out std_logic_vector(NUM-1 downto 0);
{% endfor %}
{% for field in filter_fields("pos_out") %}
    {{ pad(field.name + "_o") }} : out std32_array(NUM-1 downto 0);
{% endfor %}

{% if type == "dma" %}
    -- DMA signals
    dma_req_o           : out std_logic_vector(NUM-1 downto 0);
    dma_ack_i           : in  std_logic_vector(NUM-1 downto 0);
    dma_done_i          : in  std_logic;
    dma_addr_o          : out std32_array(NUM-1 downto 0);
    dma_len_o           : out std8_array(NUM-1 downto 0);
    dma_data_i          : in  std_logic_vector(31 downto 0);
    dma_valid_i         : in  std_logic_vector(NUM-1 downto 0);
    dma_irq_o           : out std_logic_vector(NUM-1 downto 0);
    dma_done_irq_o      : out std_logic_vector(NUM-1 downto 0);
{% endif %}
    -- Memory Interface
    read_strobe_i       : in  std_logic := '0';
    read_address_i      : in  std_logic_vector(PAGE_AW-1 downto 0) := (others => '0');
    read_data_o         : out std_logic_vector(31 downto 0);
    read_ack_o          : out std_logic;

    write_strobe_i      : in  std_logic := '0';
    write_address_i     : in  std_logic_vector(PAGE_AW-1 downto 0) := (others => '0');
    write_data_i        : in  std_logic_vector(31 downto 0) := (others => '0');
    write_ack_o         : out std_logic
);
end {{ entity }}_wrapper;

architecture rtl of {{ entity }}_wrapper is


-- Register addresses, current values and strobes, an array of these for NUM
-- Blocks

{% for field in fields %}
    {% for register in field.numbered_registers() %}
signal {{ register.name }}        : std32_array(NUM-1 downto 0);
        {% if "read" not in field.type %}
signal {{ register.name }}_wstb   : std_logic_vector(NUM-1 downto 0);
        {% endif %}
    {% endfor %}
{% endfor %}

-- Register interface common

signal read_strobe      : std_logic_vector(NUM-1 downto 0);
signal read_data        : std32_array(NUM-1 downto 0);
signal write_strobe     : std_logic_vector(NUM-1 downto 0);
signal read_addr        : natural range 0 to (2**read_address_i'length - 1);
signal write_addr       : natural range 0 to (2**write_address_i'length - 1);
signal read_ack         : std_logic_vector(NUM-1 downto 0);
signal write_ack        : std_logic_vector(NUM-1 downto 0);

begin

    -- Acknowledgement to AXI Lite interface
    write_ack_o <= or_reduce(write_ack);
    read_ack_o <= or_reduce(read_ack);
    read_data_o <= read_data(to_integer(unsigned(read_address_i(PAGE_AW-1 downto BLK_AW))));

    -- Generate NUM instances of the blocks
    GEN : FOR I IN 0 TO (NUM-1) GENERATE

        -- Sub-module address decoding
        read_strobe(I) <= compute_block_strobe(read_address_i, I) and read_strobe_i;
        write_strobe(I) <= compute_block_strobe(write_address_i, I) and write_strobe_i;


        {{ entity }}_ctrl : entity work.{{ entity }}_ctrl
        port map (
            clk_i               => clk_i,
            reset_i             => reset_i,
            bit_bus_i           => bit_bus_i,
            pos_bus_i           => pos_bus_i,

{% for field in fields %}
    {% if field in filter_fields("bit_mux") %}
            {{ pad(field.name+"_from_bus") }} => {{ field.name }}(I)(0),
    {% elif field in filter_fields("pos_mux") %}
            {{ pad(field.name+"_from_bus") }} => {{ field.name }}(I),
    {% else %}
        {% for register in field.numbered_registers() %}
            {{ pad(register.name) }} => {{ register.name }}(I),
            {% if "read" not in field.type %}
            {{ pad(register.name + "_wstb") }} => {{ register.name }}_wstb(I),
            {% endif %}
        {% endfor %}
    {% endif %}
{% endfor %}

            read_strobe_i       => read_strobe(I),
            read_address_i      => read_address_i(BLK_AW-1 downto 0),
            read_data_o         => read_data(I),
            read_ack_o          => read_ack(I),

            write_strobe_i      => write_strobe(I),
            write_address_i     => write_address_i(BLK_AW-1 downto 0),
            write_data_i        => write_data_i,
            write_ack_o         => write_ack(I)
        );

        -- Connect to the actual logic entity
        {{ entity }} : entity work.{{ entity }}
        port map (
{% for field in fields %}
    {% if field in filter_fields("bit_mux") %}
            {{ pad(field.name +"_i") }} => {{ field.name }}(I)(0),
    {% elif field in filter_fields("pos_mux") %}
            {{ pad(field.name +"_i") }} => {{ field.name }}(I),
    {% elif field in filter_fields(".*_out") %}
            {{ pad(field.name + "_o") }} => {{ field.name }}_o(I),
    {% else %}
        {% for register in field.numbered_registers() %}
             {{ pad(register.name) }} => {{ register.name }}(I),
        {% endfor %}
    {% endif %}
    {% if field.wstb %}
            {% for register in field.numbered_registers() %}
            {{ pad(register.name + "_wstb") }} => {{ register.name }}_wstb(I),
            {% endfor %}
    {% endif %}
{% endfor %}
{% if type == "dma" %}
            dma_req_o           => dma_req_o(I),
            dma_ack_i           => dma_ack_i(I),
            dma_done_i          => dma_done_i,
            dma_addr_o          => dma_addr_o(I),
            dma_len_o           => dma_len_o(I),
            dma_data_i          => dma_data_i,
            dma_valid_i         => dma_valid_i(I),
            dma_irq_o           => dma_irq_o(I),
            dma_done_irq_o      => dma_done_irq_o(I),
{% endif %}
            clk_i               => clk_i
        );

    END GENERATE;

end rtl;
