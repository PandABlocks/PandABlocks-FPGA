#!/usr/bin/env python
import logging
import subprocess
from configparser import ConfigParser
from pathlib import Path
from typing import List
import pytest
from cocotb_tools import runner  # type: ignore
from dataclasses import dataclass
import sys
logger = logging.getLogger(__name__)

SCRIPT_DIR_PATH = Path(__file__).parent.resolve()
TOP_PATH = SCRIPT_DIR_PATH.parent.parent
MODULES_PATH = TOP_PATH / "modules"
WORKING_DIR = Path.cwd()

sys.path.insert(1, str(SCRIPT_DIR_PATH))


def read_ini(path: List[str] | str) -> ConfigParser:
    """Read INI file and return its contents.

    Args:
        path: Path to INI file.
    Returns:
        ConfigParser object containing INI file.
    """
    app_ini = ConfigParser()
    app_ini.read(path)
    return app_ini


def get_timing_inis(module: str) -> dict[str, ConfigParser]:
    """Get a module's timing ini files.

    Args:
        module: Name of module.
    Returns:
        Dictionary of filepath: file contents for any timing.ini files in the
        module directory.
    """
    ini_paths = (MODULES_PATH / module).glob("*.timing.ini")
    return {str(path): read_ini(str(path.resolve())) for path in ini_paths}


def get_module_build_args(module: str, panda_build_dir: str | Path) -> list[str]:
    """Get simulation build arguments from a module's test config file.

    Args:
        module: Name of module.
        panda_build_dir: Path to autogenerated HDL files.
    Returns:
        List of extra build arguments.
    """
    test_config_path = MODULES_PATH / module / "test_config.py"
    if test_config_path.exists():
        g = {"TOP_PATH": TOP_PATH, "BUILD_PATH": Path(panda_build_dir)}
        code = open(str(test_config_path)).read()
        exec(code, g)
        args: list[str] = g.get("EXTRA_BUILD_ARGS", [])  # type: ignore
        return args
    return []


def order_hdl_files(
    hdl_files: list[Path], build_dir: str | Path, top_level: str
) -> list[Path]:
    """Put vhdl source files in compilation order. This is neccessary for the
    nvc simulator as it does not order the files iself before compilation.

    Args:
        hdl_files: List of vhdl source files.
        build_dir: Build directory for simulation.
        top_level: Name of the top-level entity.
    """
    command: list[str] = [
        "vhdeps",
        "dump",
        top_level,
        "-o",
        f'{WORKING_DIR / build_dir / "order"}',
    ]
    for file in hdl_files:
        command.append(f"--include={str(file)}")
    command_str = " ".join(command)
    Path(WORKING_DIR / build_dir).mkdir(exist_ok=True)
    subprocess.run(["/usr/bin/env"] + command)
    try:
        with open(WORKING_DIR / build_dir / "order") as order:
            ordered_hdl_files = [
                Path(line.strip().split(" ")[-1]) for line in order.readlines()
            ]
        return ordered_hdl_files
    except FileNotFoundError as error:
        logger.warning(f"Likely that the following command failed:\n{command_str}")
        logger.warning(error)
        logger.warning("HDL FILES HAVE NOT BEEN PUT INTO COMPILATION ORDER!")
        return hdl_files


def get_module_hdl_files(
    module: str, top_level: str, build_dir: str | Path, panda_build_dir: str | Path
):
    """Get HDL files needed to simulate a module from its test config file.

    Args:
        module: Name of module.
        top_level: Top level entity of module being tested.
        build_dir: Name of simulation build directory.
        panda_build_dir: Path to autogenerated HDL files.
    Returns:
        List of paths to the HDL files.
    """
    module_dir_path = MODULES_PATH / module
    test_config_path = module_dir_path / "test_config.py"
    g = {"TOP_PATH": TOP_PATH, "BUILD_PATH": Path(panda_build_dir)}
    if test_config_path.exists():
        code = open(str(test_config_path)).read()
        exec(code, g)
        g.get("EXTRA_HDL_FILES", [])
        extra_files: list[Path] = list(g.get("EXTRA_HDL_FILES", []))  # type: ignore
        extra_files_2: list[Path] = []
        for my_file in extra_files:
            if str(my_file).endswith(".vhd"):
                extra_files_2.append(my_file)
            else:
                extra_files_2 = extra_files_2 + list(my_file.glob("**/*.vhd"))
    else:
        extra_files_2 = []
    result = extra_files_2 + list((module_dir_path / "hdl").glob("*.vhd"))
    ordered = order_hdl_files(result, build_dir, top_level)
    logger.info("Gathering the following VHDL files:")
    for my_file in ordered:
        logger.info(my_file)
    return ordered


def get_module_top_level(module: str, panda_build_dir: str | Path) -> str:
    """Get top level entity from a module's test config file.
    If none is found, assume top level entity is the same as the module name.

    Args:
        module: Name of module.
        panda_build_dir: Path to autogenerated HDL files.
    Returns:
        Name of top level entity.
    """
    test_config_path = MODULES_PATH / module / "test_config.py"
    if test_config_path.exists():
        g = {"TOP_PATH": TOP_PATH, "BUILD_PATH": Path(panda_build_dir)}
        code = open(str(test_config_path)).read()
        exec(code, g)
        top_level: str = g.get("TOP_LEVEL", None)  # type: ignore
        if top_level:
            return top_level
    return module


def get_simulator_build_args(simulator: str) -> list[str]:
    """Get arguments for the build stage.

    Args:
        simulator: Name of simulator being used.
    Returns:
        List of build arguments.
    """
    if simulator == "ghdl":
        return ["--std=08", "-fsynopsys", "-Wno-hide"]
    elif simulator == "nvc":
        return ["--std=2008"]
    else:
        raise NotImplementedError(f"{simulator} is not a valid simulator")


def get_test_args(simulator: str, build_args: list[str], test_name: str) -> list[str]:
    """Get arguments for the test stage.

    Args:
        simulator: Name of simulator being used.
        build_args: Arguments used for the build stage.
        test_name: Name of test being carried out.
    Returns:
        List of test arguments.
    """
    test_name = test_name.replace(" ", "_").replace("/", "_")
    if simulator == "ghdl":
        return build_args
    elif simulator == "nvc":
        return ["--ieee-warnings=off", f"--wave={test_name}.vcd"]
    else:
        raise NotImplementedError(f"{simulator} is not a valid simulator")


def get_elab_args(simulator: str) -> list[str]:
    """Get arguments for the elaboration stage.

    Args:
        simulator: Name of simulator being used.
    Returns:
        List of elaboration arguments.
    """
    if simulator == "nvc":
        return ["--cover"]
    else:
        return []


def get_plusargs(simulator: str, test_name: str) -> list[str]:
    """Get plusargs to for the test stage.

    Args:
        simulator: Name of simulator being used.
        test_name: Name of test being carried out.

    Returns:
        List of plus arguments.
    """
    test_name = test_name.replace(" ", "_").replace("/", "_")
    vcd_filename = f"{test_name}.vcd"
    if simulator == "ghdl":
        return [f"--vcd={vcd_filename}"]
    elif simulator == "vcd":
        return []
    return []


def collect_coverage_file(
    build_dir: str | Path, top_level: str, test_name: str
) -> Path:
    """Move coverage file to the coverage directory

    Args:
        build_dir: Simulation build directory.
        top_level: Top level entity being tested.
        test_name: Name of test being carried out.
    Returns:
        New file path of the coverage file.
    """
    coverage_path = Path(WORKING_DIR / build_dir / "coverage")
    Path(coverage_path).mkdir(exist_ok=True)
    old_file_path = Path(
        WORKING_DIR / build_dir / "top" / f"_TOP.{top_level.upper()}.elab.covdb"
    )
    test_name = test_name.replace(" ", "_").replace("/", "_")
    new_file_path = Path(
        coverage_path / f"_TOP.{top_level.upper()}.{test_name}.elab.covdb"
    )
    subprocess.run(["mv", old_file_path, new_file_path])
    return new_file_path


def merge_coverage_data(
    build_dir: str | Path, module: str, file_paths: list[Path]
) -> Path:
    """Merges coverage files from each test to create an overall coverage
    report for a module.

    Args:
        build_dir: Simulation build directory.
        module: Name of module.
        file_paths: List of paths to coverage files from each test.
    Returns:
        File path for the coverage report file.
    """
    merged_path = Path(WORKING_DIR / build_dir / "coverage" / f"merged.{module}.covdb")
    command = (
        ["nvc", "--cover-merge", "-o"]
        + [str(merged_path)]
        + [str(file_path) for file_path in file_paths]
    )
    subprocess.run(command)
    return merged_path


def export_coverage_data(
    simulator: str,
    output_path: Path,
    file_paths: list[Path],
    format: str = "cobertura",
):
    """Merges merge coverage files from each module to create an overall coverage
    report in an xml format suitable for codecov.

    Args:
        simulator: string name of simulator
        output_path: Path of the output coverage report to write
        file_paths: List of Paths to coverage files from each module.
        format: coverage format to pass to simulator
    """
    if simulator == "nvc":
        command = (
            [simulator,
            "--cover-export",
            f"--format={format}",
            f"--relative={str(TOP_PATH)}",
            "-o"]
            + [str(output_path)]
            + [str(file_path) for file_path in file_paths]
        )
        subprocess.run(command)


def cleanup_dir(test_name: str, build_dir: str | Path):
    """Creates a subdirectory for a test and moves all files generated from
    that test into it.

    Args:
        test_name: Name of test.
        build_dir: Simulation build directory.
    """
    test_name = test_name.replace(" ", "_").replace("/", "_")
    (WORKING_DIR / build_dir / test_name).mkdir(exist_ok=True)
    for file in (WORKING_DIR / build_dir).glob(f"{test_name}*"):
        if file.is_file():
            new_name = str(file).split("/")[-1].replace(test_name, "")
            if new_name.endswith(".vcd"):
                new_name = "wave" + new_name
            new_name = new_name.lstrip("_")
            file.rename(WORKING_DIR / build_dir / test_name / new_name)


@dataclass
class ModuleData:
    module: str
    build_dir: str
    build_args: list[str]
    top_level: str
    test_runner: runner.Runner


modules_data: dict[str, ModuleData] = {}


def do_test_module(
    module_data: ModuleData,
    timing_ini: str,
    test_name: str | None = None,
    simulator: str = "nvc",
    panda_build_dir: str | Path = "/build",
    collect: bool = False,
) -> Path | None:
    """Run tests for a module.

    Args:
        module_data: ModuleData dataclass containing necessary information
            for running the test
        timing_ini: string path of the timing_ini file for the test.
        test_name: Name of specific test to run. If not specified, all tests
            for that module will be run.
        simulator: Name of simulator to use for simulation.
        panda_build_dir: Location of autogenerated HDL files.
        collect: If True, collect output signals expected and actual values.
    Returns:
        Lists of tests that passed and failed respectively, path to coverage.
    """
    if not Path(MODULES_PATH / module_data.module).is_dir():
        raise FileNotFoundError(
            "No such directory: '{}'".format(Path(MODULES_PATH / module_data.module))
        )

    coverage_file_paths: list[Path] = []
    coverage_report_path: Path | None = None

    path = timing_ini

    module_data.test_runner.test(  # type: ignore
        hdl_toplevel=module_data.top_level,
        test_module="cocotb_simulate_test",
        build_dir=module_data.build_dir,
        test_args=get_test_args(simulator, module_data.build_args, test_name),
        elab_args=get_elab_args(simulator),
        plusargs=get_plusargs(simulator, test_name),
        extra_env={
            "module": module_data.module,
            "test_name": test_name,
            "simulator": simulator,
            "sim_build_dir": str(module_data.build_dir),
            "timing_ini_path": str(path),
            "panda_build_dir": str(panda_build_dir),
            "collect": str(collect),
        },
    )
    if simulator == "nvc":
        coverage_file_paths.append(
            collect_coverage_file(
                module_data.build_dir, module_data.top_level, test_name)
        )
    cleanup_dir(test_name, module_data.build_dir)
    if simulator == "nvc":
        coverage_report_path = merge_coverage_data(
            module_data.build_dir, module_data.module, coverage_file_paths
        )
    return coverage_report_path


def get_cocotb_testable_modules():
    """Get list of modules that contain a timing.ini file file.

    Returns:
        List of names of testable modules.
    """
    modules = MODULES_PATH.glob("*/*.timing.ini")
    return list(module.parent.name for module in modules)


@dataclass
class TestInfo:
    __test__ = False
    module: str
    test_name: str
    timing_ini: str


coverage_reports: dict[str, Path | None] = {}
tests_info: list[TestInfo] = []


def _populate_test_info(tests_info):
    modules = get_cocotb_testable_modules()
    for module in modules:
        timing_inis = get_timing_inis(module)
        for ini_path, timing_ini in timing_inis.items():
            sections = timing_ini.sections()
            for section in sections:
                if section.strip() != ".":
                    test_name = section
                    tests_info.append(
                        TestInfo(module=module,
                                 test_name=test_name,
                                 timing_ini=ini_path)
                    )
    return tests_info


_populate_test_info(tests_info)


@pytest.mark.parametrize(
    "info",
    tests_info,
    ids = [f"{info.module}: {info.test_name}" for info in tests_info]
)
def test_module_test(info, sim, panda_build_dir, skip, collect):
    """Perform test run."""
    skip_list: list[str] = skip.split(",") if skip else []
    if info.module in skip_list:
        pytest.skip(f"Module {info.module} skipped")

    if info.module not in modules_data:
        build_dir = f"sim_build_{info.module}"
        build_args = get_simulator_build_args(sim)
        build_args += get_module_build_args(info.module, panda_build_dir)
        top_level = get_module_top_level(info.module, panda_build_dir)
        test_runner: runner.Runner = runner.get_runner(sim)  # type: ignore
        test_runner.build(  # type: ignore
            sources=get_module_hdl_files(
                info.module, top_level, build_dir, panda_build_dir),
            build_dir=build_dir,
            hdl_toplevel=top_level,
            build_args=build_args,
            clean=True,
        )
        modules_data[info.module] = ModuleData(
            module = info.module,
            build_dir = build_dir,
            build_args = build_args,
            top_level = top_level,
            test_runner = test_runner
        )
    coverage_reports[info.module] = do_test_module(
        modules_data[info.module],
        info.timing_ini,
        test_name=info.test_name,
        simulator=sim,
        panda_build_dir=panda_build_dir,
        collect=collect,
    )


@pytest.fixture(scope="module", autouse=True)
def export_coverage(sim):
    yield
    report_paths = [path for path in coverage_reports.values() if path is not None]
    export_coverage_data(sim, Path("cocotb_coverage.xml"), report_paths)
