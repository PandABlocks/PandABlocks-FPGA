-- AUTOGENERATED
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.addr_defines.all;
use work.top_defines.all;

entity fmc_acq427_ctrl is
port (
    -- Clock and Reset
    clk_i               : in  std_logic;
    reset_i             : in  std_logic;
    bit_bus_i           : in  bit_bus_t;
    pos_bus_i           : in  pos_bus_t;
    -- Block Parameters
    IN_GAIN1_REG        : out std_logic_vector(31 downto 0);
    IN_GAIN1_REG_wstb   : out std_logic;
    IN_GAIN2_REG        : out std_logic_vector(31 downto 0);
    IN_GAIN2_REG_wstb   : out std_logic;
    IN_GAIN3_REG        : out std_logic_vector(31 downto 0);
    IN_GAIN3_REG_wstb   : out std_logic;
    IN_GAIN4_REG        : out std_logic_vector(31 downto 0);
    IN_GAIN4_REG_wstb   : out std_logic;
    IN_GAIN5_REG        : out std_logic_vector(31 downto 0);
    IN_GAIN5_REG_wstb   : out std_logic;
    IN_GAIN6_REG        : out std_logic_vector(31 downto 0);
    IN_GAIN6_REG_wstb   : out std_logic;
    IN_GAIN7_REG        : out std_logic_vector(31 downto 0);
    IN_GAIN7_REG_wstb   : out std_logic;
    IN_GAIN8_REG        : out std_logic_vector(31 downto 0);
    IN_GAIN8_REG_wstb   : out std_logic;
    OUT_VAL1_from_bus   : out std_logic_vector(31 downto 0);
    OUT_VAL2_from_bus   : out std_logic_vector(31 downto 0);
    OUT_VAL3_from_bus   : out std_logic_vector(31 downto 0);
    OUT_VAL4_from_bus   : out std_logic_vector(31 downto 0);
    -- Memory Bus Interface
    read_strobe_i       : in  std_logic;
    read_address_i      : in  std_logic_vector(BLK_AW-1 downto 0);
    read_data_o         : out std_logic_vector(31 downto 0);
    read_ack_o          : out std_logic;

    write_strobe_i      : in  std_logic;
    write_address_i     : in  std_logic_vector(BLK_AW-1 downto 0);
    write_data_i        : in  std_logic_vector(31 downto 0);
    write_ack_o         : out std_logic
);
end fmc_acq427_ctrl;

architecture rtl of fmc_acq427_ctrl is

signal OUT_VAL1      : std_logic_vector(31 downto 0);
signal OUT_VAL1_wstb : std_logic;

signal OUT_VAL2      : std_logic_vector(31 downto 0);
signal OUT_VAL2_wstb : std_logic;

signal OUT_VAL3      : std_logic_vector(31 downto 0);
signal OUT_VAL3_wstb : std_logic;

signal OUT_VAL4      : std_logic_vector(31 downto 0);
signal OUT_VAL4_wstb : std_logic;


-- Register interface common

signal read_addr        : natural range 0 to (2**read_address_i'length - 1);
signal write_addr       : natural range 0 to (2**write_address_i'length - 1);

begin

    -- Sub-module address decoding
    read_addr <= to_integer(unsigned(read_address_i));
    write_addr <= to_integer(unsigned(write_address_i));

    read_ack_delay : entity work.delay_line
    generic map (DW => 1)
    port map (
        clk_i       => clk_i,
        data_i(0)   => read_strobe_i,
        data_o(0)   => read_ack_o,
        DELAY_i       => RD_ADDR2ACK
    );

    -- Control System Register Interface
    REG_WRITE : process(clk_i)
    begin
        if rising_edge(clk_i) then
            -- Zero all the write strobe arrays, we set them below
            IN_GAIN1_REG_wstb <= '0';
            IN_GAIN2_REG_wstb <= '0';
            IN_GAIN3_REG_wstb <= '0';
            IN_GAIN4_REG_wstb <= '0';
            IN_GAIN5_REG_wstb <= '0';
            IN_GAIN6_REG_wstb <= '0';
            IN_GAIN7_REG_wstb <= '0';
            IN_GAIN8_REG_wstb <= '0';
            OUT_VAL1_wstb <= '0';
            OUT_VAL2_wstb <= '0';
            OUT_VAL3_wstb <= '0';
            OUT_VAL4_wstb <= '0';
            if (write_strobe_i = '1') then
                -- Set the specific write strobe that has come in
                case write_addr is
                    when FMC_ACQ427_IN_GAIN1_REG_addr =>
                        IN_GAIN1_REG <= write_data_i;
                        IN_GAIN1_REG_wstb <= '1';
                    when FMC_ACQ427_IN_GAIN2_REG_addr =>
                        IN_GAIN2_REG <= write_data_i;
                        IN_GAIN2_REG_wstb <= '1';
                    when FMC_ACQ427_IN_GAIN3_REG_addr =>
                        IN_GAIN3_REG <= write_data_i;
                        IN_GAIN3_REG_wstb <= '1';
                    when FMC_ACQ427_IN_GAIN4_REG_addr =>
                        IN_GAIN4_REG <= write_data_i;
                        IN_GAIN4_REG_wstb <= '1';
                    when FMC_ACQ427_IN_GAIN5_REG_addr =>
                        IN_GAIN5_REG <= write_data_i;
                        IN_GAIN5_REG_wstb <= '1';
                    when FMC_ACQ427_IN_GAIN6_REG_addr =>
                        IN_GAIN6_REG <= write_data_i;
                        IN_GAIN6_REG_wstb <= '1';
                    when FMC_ACQ427_IN_GAIN7_REG_addr =>
                        IN_GAIN7_REG <= write_data_i;
                        IN_GAIN7_REG_wstb <= '1';
                    when FMC_ACQ427_IN_GAIN8_REG_addr =>
                        IN_GAIN8_REG <= write_data_i;
                        IN_GAIN8_REG_wstb <= '1';
                    when FMC_ACQ427_OUT_VAL1_addr =>
                        OUT_VAL1 <= write_data_i;
                        OUT_VAL1_wstb <= '1';
                    when FMC_ACQ427_OUT_VAL2_addr =>
                        OUT_VAL2 <= write_data_i;
                        OUT_VAL2_wstb <= '1';
                    when FMC_ACQ427_OUT_VAL3_addr =>
                        OUT_VAL3 <= write_data_i;
                        OUT_VAL3_wstb <= '1';
                    when FMC_ACQ427_OUT_VAL4_addr =>
                        OUT_VAL4 <= write_data_i;
                        OUT_VAL4_wstb <= '1';
                    when others =>
                        null;
                end case;
            end if;
        end if;
    end process;

    --
    -- Status Register Read     // NOT dealt with yet!      -- Need MUX for read_data(I)
                                                            -- find examples that actually have register reads...
                                                            -- Current implementation taken from old panda_block_ctrl_template
    --
    REG_READ : process(clk_i)
    begin
        if rising_edge(clk_i) then
            case (read_addr) is
                when others =>
                    read_data_o <= (others => '0');
            end case;
        end if;
    end process;

    --
    -- Instantiate Delay Blocks for Bit and Position Bus Fields
    --
    posmux_OUT_VAL1 : entity work.posmux
    port map (
        clk_i        => clk_i,
        pos_bus_i    => pos_bus_i,
        posn_o       => OUT_VAL1_from_bus,
        posmux_sel_i => OUT_VAL1
    );

    posmux_OUT_VAL2 : entity work.posmux
    port map (
        clk_i        => clk_i,
        pos_bus_i    => pos_bus_i,
        posn_o       => OUT_VAL2_from_bus,
        posmux_sel_i => OUT_VAL2
    );

    posmux_OUT_VAL3 : entity work.posmux
    port map (
        clk_i        => clk_i,
        pos_bus_i    => pos_bus_i,
        posn_o       => OUT_VAL3_from_bus,
        posmux_sel_i => OUT_VAL3
    );

    posmux_OUT_VAL4 : entity work.posmux
    port map (
        clk_i        => clk_i,
        pos_bus_i    => pos_bus_i,
        posn_o       => OUT_VAL4_from_bus,
        posmux_sel_i => OUT_VAL4
    );


end rtl;
